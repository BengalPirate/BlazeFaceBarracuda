#pragma kernel Postprocess2

//
// 2nd postprocessor (overlap removal)
//

#include "Common.hlsl"

#define IOU_THRESHOLD 0.5

// Input uniforms
ConsumeStructuredBuffer<Detection> _Input;
ByteAddressBuffer _Count;

// Output uniforms
AppendStructuredBuffer<Detection> _Output;

// Detection entry cache
groupshared Detection _entry[MAX_DETECTION];
groupshared bool _flag[MAX_DETECTION];

[numthreads(1, 1, 1)]
void Postprocess2(uint3 id : SV_DispatchThreadID)
{
    // Detection entry cache initialization
    uint entry_count = _Count.Load(0);
    if (entry_count == 0) return;

    for (uint i = 0; i < entry_count; i++)
    {
        _entry[i] = _Input.Consume();
        _flag[i] = true;
    }

    // Overlap test permutation
    for (i = 0; i < entry_count - 1; i++)
    {
        if (!_flag[i]) continue;

        for (uint j = i + 1; j < entry_count; j++)
        {
            if (!_flag[j]) continue;

            // Overlap test
            if (CalculateIOU(_entry[i], _entry[j]) < IOU_THRESHOLD) continue;

            // Score comparison
            if (_entry[i].score < _entry[j].score)
            {
                _flag[i] = false;
                // The box in the outer loop is removed. Break the inner loop.
                break;
            }
            else
                _flag[j] = false;
        }
    }

    // Output aggregation
    for (i = 0; i < entry_count; i++)
        if (_flag[i]) _Output.Append(_entry[i]);
}
